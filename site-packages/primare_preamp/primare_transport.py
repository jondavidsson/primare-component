import abc
import serial  # type: ignore
import threading

from typing import Optional

import logging

logging.basicConfig()
_LOGGER = logging.getLogger("primare_preamp.transport")
_LOGGER.debug("Primare transport")


DEFAULT_TIMEOUT = 1


class PrimareTransport(abc.ABC):
    @abc.abstractmethod
    def communicate(self, command: str) -> str:
        pass


class SerialPortTransport(PrimareTransport):
    """Transport for Primare protocol over RS-232."""

    def __init__(self, serial_port: str) -> None:
        """Create RS232 connection."""
        self.ser = serial.Serial(
            serial_port,
            baudrate=4800,
            bytesize=8,
            stopbits=1,
            parity="N",
            timeout=DEFAULT_TIMEOUT,
            write_timeout=DEFAULT_TIMEOUT,
        )
        self.lock = threading.Lock()

    def _open_connection(self) -> None:
        if not self.ser.is_open:
            self.ser.open()
            _LOGGER.debug("serial open: %s", self.ser.is_open)

    def communicate(self, command: str) -> str:
        with self.lock:
            self._open_connection()

            self.ser.write(f"\r{command}\r".encode("utf-8"))
            # To get complete messages, always read until we get '\r'
            # Messages will be of the form '\rMESSAGE\r' which
            # pyserial handles nicely
            msg = self.ser.read_until(b'\x03')
            if not msg.strip():  # discard '\r' if it was sent
                msg = self.ser.read_until(b'\x03')
            assert isinstance(msg, bytes)
            return msg.strip().decode()